import mysql.connector
from mysql.connector import Error
import tkinter as tk
import tkinter.ttk as ttk
from os import system
from platform import system as platform



# Window GUI stuff
class myGUI:
    def __init__(self, conn):
        self.conn = conn
        self.root = tk.Tk()
        # Bring app to front on macos
        if platform() == 'Darwin':  # How Mac OS X is identified by Python
            system('''/usr/bin/osascript -e 'tell app "Finder" to set frontmost of process "Python" to true' ''')
        self.style = ttk.Style()
        self.root.geometry('800x400')
        self.root.title('Application')

        # Quit app button
        self.quit_button = ttk.Button(
                self.root,
                text='Quit',
                width=25,
                command=self.root.destroy
        )

        self.login_frame = ttk.Frame(self.root)
        self.login_frame.pack(pady=5)

        self.loginfield = ttk.Entry(self.login_frame, width=30)
        self.loginfield.grid(row=0, column=0, padx=(0,10))

        self.loginConfirm = ttk.Button(
                self.login_frame,
                text='login',
                command=self.login
                )
        self.loginConfirm.grid(row=0, column=1)

        self.register_frame = ttk.Frame(self.root)
        self.register_frame.pack(pady=5)

        self.registerfield = ttk.Entry(self.register_frame, width=30)
        self.registerfield.grid(row=0, column=0, padx=(0,10))

        self.registerConfirm = ttk.Button(
                self.register_frame,
                text='register new user',
                command=self.login
                )
        self.registerConfirm.grid(row=0, column=1)


        self.l1 = tk.Label(self.root, text="hi", width=25)
        self.l1.pack()

        self.quit_button.pack(pady=5)

        self.root.bind("<Button-1>", self.clear_focus)

        self.root.mainloop()

    def clear_focus(self, event):
        if event.widget == self.root:
            self.root.focus_set()

    def buttonCallback(self):
        self.l1['text'] = 'hello'

    def login(self):
        user_text = self.loginfield.get()
        try:
            cursor = self.conn.cursor(dictionary=True, prepared=True)
            sql = "SELECT age FROM users WHERE name = %s"
            params = (user_text,)
            cursor.execute(sql, params)
            row = cursor.fetchone()
            self.l1['text'] = user_text + " is logged in. Age is " + str(row["age"])
        except Error as e:
            print_sql_error(e, "login")
            raise
        finally:
            cursor.close()



# Configuration struct equivalent
class DbConfig:
    def __init__(self,
                 host="127.0.0.1",
                 port=3306,
                 user="root",
                 password="sinatra1",
                 database="cs3260-project"):
        self.host = host
        self.port = port
        self.user = user
        self.password = password
        self.database = database

def print_sql_error(e: Error, where: str):
    # Print detailed error info
    print(f"[SQL ERROR @ {where}] {e.msg} | errno: {e.errno} | sqlstate: {e.sqlstate}")

# A simple user-row structure
class User:
    def __init__(self, id: int, name: str, age: int = None):
        self.id = id
        self.name = name
        self.age = age

def ensure_schema_and_tables(conn, cfg: DbConfig):
    """
    Ensures the database schema and table exist.
    If the database does not exist, create it.
    Then switch to using it and create the `users` table if absent.
    """
    cursor = conn.cursor()
    try:
        # Create database if missing
        cursor.execute(f"CREATE DATABASE IF NOT EXISTS `{cfg.database}`")
        # Use the database
        conn.database = cfg.database
        # Create the table `users`
        cursor.execute(
            """
            CREATE TABLE IF NOT EXISTS users (
              id INT AUTO_INCREMENT PRIMARY KEY,
              name VARCHAR(100) NOT NULL,
              age INT NULL,
              UNIQUE KEY uq_users_name (name)
            ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
            """
        )
        conn.commit()
    except Error as e:
        print_sql_error(e, "ensure_schema_and_tables")
        raise
    finally:
        cursor.close()

def insert_user(conn, user: User) -> int:
    """
    Inserts a single user via a prepared statement and returns the generated id.
    """
    cursor = conn.cursor(prepared=True)
    try:
        sql = "INSERT INTO users(name, age) VALUES(%s, %s)"
        params = (user.name, user.age)
        cursor.execute(sql, params)
        # get last inserted id
        conn.commit()
        # Cursor lastrowid may not work for prepared; use SELECT LAST_INSERT_ID()
        cursor2 = conn.cursor()
        cursor2.execute("SELECT LAST_INSERT_ID()")
        row = cursor2.fetchone()
        cursor2.close()
        return row[0] if row else 0
    except Error as e:
        print_sql_error(e, "insert_user")
        conn.rollback()
        raise
    finally:
        cursor.close()

def insert_users_bulk(conn, users: list[User]):
    """
    Bulk insert multiple users using one prepared statement.
    """
    cursor = conn.cursor(prepared=True)
    try:
        sql = "INSERT INTO users(name, age) VALUES(%s, %s)"
        params = [(u.name, u.age) for u in users]
        cursor.executemany(sql, params)
        conn.commit()
    except Error as e:
        print_sql_error(e, "insert_users_bulk")
        conn.rollback()
        raise
    finally:
        cursor.close()

def update_user_age_by_name(conn, name: str, new_age: int) -> int:
    """
    Update a user's age by name, returns number of rows affected.
    """
    cursor = conn.cursor(prepared=True)
    try:
        sql = "UPDATE users SET age = %s WHERE name = %s"
        params = (new_age, name)
        cursor.execute(sql, params)
        affected = cursor.rowcount
        conn.commit()
        return affected
    except Error as e:
        print_sql_error(e, "update_user_age_by_name")
        conn.rollback()
        raise
    finally:
        cursor.close()

def get_users_by_min_age(conn, min_age: int) -> list[User]:
    """
    Select users with age >= min_age, return list of User objects.
    """
    cursor = conn.cursor(dictionary=True, prepared=True)
    out = []
    try:
        sql = "SELECT id, name, age FROM users WHERE age >= %s ORDER BY age DESC, id ASC"
        params = (min_age,)
        cursor.execute(sql, params)
        for row in cursor:
            u = User(
                id=row["id"],
                name=row["name"],
                age=row["age"] if row["age"] is not None else 0
            )
            out.append(u)
        return out
    except Error as e:
        print_sql_error(e, "get_users_by_min_age")
        raise
    finally:
        cursor.close()

def demo_transaction(conn):
    """
    Demonstrates a transaction: disable autocommit, perform multiple operations,
    and commit or rollback based on success/failure.
    """
    try:
        # Start transaction: turn off autocommit
        conn.autocommit = False
        # Bulk insert
        insert_users_bulk(conn, [User(0, "alice", 24), User(0, "bob", 29)])
        # Update one
        changed = update_user_age_by_name(conn, "alice", 25)
        print(f"Rows updated in transaction: {changed}")
        # Uncomment to simulate an error (e.g., unique constraint violation)
        # insert_user(conn, User(0, "alice", 40))
        # Commit transaction
        conn.commit()
        print("Transaction committed.")
    except Error as e:
        print_sql_error(e, "demo_transaction")
        try:
            conn.rollback()
            print("Transaction rolled back.")
        except Error as e2:
            print_sql_error(e2, "rollback")
        raise
    finally:
        # Restore autocommit
        conn.autocommit = True

def main():
    cfg = DbConfig()
    try:
        # Step 1: Connect to MySQL server (without specifying database yet)
        conn = mysql.connector.connect(
            host=cfg.host,
            port=cfg.port,
            user=cfg.user,
            password=cfg.password,
            # no database arg yet
        )
        if conn.is_connected():
            print("Successfully connected to MySQL server")
        else:
            print("Failed to connect to MySQL server")
            return

        # Step 2: Ensure schema & table exist
        ensure_schema_and_tables(conn, cfg)

        # Step 3: Clear existing rows (for demo only)
        cursor = conn.cursor()
        cursor.execute("DELETE FROM users")
        conn.commit()
        cursor.close()

        # Step 4: Insert a single user
        new_id = insert_user(conn, User(0, "carol", 32))
        print(f"Inserted carol with id = {new_id}")

        # Step 5: Demo transaction (insert + update)
        try:
            demo_transaction(conn)
        except Error:
            print("Transaction demo failed (rolled back).")

        # Step 6: Query users with age >= 25
        results = get_users_by_min_age(conn, 25)
        print("\nUsers with age >= 25:")
        print(f"{'ID':<5}{'Name':<12}Age")
        for u in results:
            print(f"{u.id:<5}{u.name:<12}{u.age}")

        # Step 7: Update bob's age outside of transaction
        affected = update_user_age_by_name(conn, "bob", 31)
        print(f"\nUpdated rows (bob -> 31): {affected}")

        # Step 8: Show final table state
        cursor = conn.cursor(dictionary=True)
        cursor.execute("SELECT id, name, age FROM users ORDER BY id")
        print("\nFinal users:")
        for row in cursor:
            print(f"ID={row['id']} | name={row['name']} | age={row['age'] if row['age'] is not None else -1}")
        cursor.close()

        gui = myGUI(conn)
    except Error as e:
        print_sql_error(e, "main")
    except Exception as e:
        print(f"[STD ERROR] {e}")
    finally:
        if conn and conn.is_connected():
            conn.close()
            print("MySQL connection closed.")


if __name__ == "__main__":
    main()
